import re
from pathlib import Path
from random import randint
from collections import OrderedDict
from datetime import datetime 

input_file = Path(r"../userraw/maps/mp/bots/_bot_chat.gsc")
output_file = Path(r"../userraw/maps/mp/bots/_bot_chat.gsc")
def_file = Path(r"../userraw/maps/mp/bots/_bot_language_en.gsc")

def format_var(varStr): return re.sub('\W|^(?=\d)','_', "lang_"+varStr.strip().lower())

defs = {}
with open(input_file, "r") as file:
    content = file.read()

done = 0;failed = 0
regexes = [
  re.compile(r'BotDoChat\(\s*\d+,\s*("[^\"]+")'),
  re.compile(r'BotDoChat.*("[^\"]+")\s*\);'),
  re.compile(r'message\s*=\s*\(\s*(".+")\s*\);'),
  re.compile(r'message\s*=.*("[^\"]+")\s*\);')
]
for regex in regexes:
  matches = regex.findall(content)
  for match in matches:
    try:
      original_text = match
      original_text_no_quotes = original_text.replace("\"","")
      if (len(original_text_no_quotes) < 3) \
      or original_text.count('\"') > 2 \
      or original_text_no_quotes.strip() == "^": continue
      print(f"[{done}/{done+failed}] \"{original_text}\"")
      formatted_text = format_var(original_text)
      if not formatted_text:
        failed += 1
        continue
      if formatted_text in defs.keys() and defs[formatted_text] != original_text:
        formatted_text += str(randint(0,9999999))
      print(f"=> \"{formatted_text}\"")
      replacement = f"BotGetLang(\"{formatted_text}\")"
      content = content.replace(original_text, replacement)
      defs[formatted_text] = original_text
      done += 1
    except Exception as ex:
      failed += 1
      print(ex)

print(f"Parsed {done} strings")
with open(output_file, 'w') as f:
    f.write(content)
defs = OrderedDict(sorted(defs.items()))
with open(def_file, 'w', encoding='utf-8') as f:
  f.write(f"// Generated by {__file__}\n")
  f.write(f"// Generated at {datetime.now()}\n\n")
  f.write("BotGetLang(string) {\n")
  for k, v in defs.items():
    v = v.replace('\\','\\\\')
    f.write(f"\tif ((string) == \"{k}\") return {v};\n")
  f.write("}")
